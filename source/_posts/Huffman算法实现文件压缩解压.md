---
title: Huffman算法实现文件压缩解压
comments: true
copyright: true
date: 2020-01-02 20:33:11
updated:
tags: 
- Huffman编码 
- 文件解压缩
categories: 其他
keywords: Huffman编码 文件解压缩
description: 基于Huffman编码算法实现文件压缩解压
top_img: https://cdn.jsdelivr.net/gh/TOMsworkspace/BlogHelper@1.0/C语言中输入输出所有格式控制符/figure1.jpg
cover: https://cdn.jsdelivr.net/gh/TOMsworkspace/BlogHelper@1.0/C语言中输入输出所有格式控制符/figure1.jpg
toc: true
toc_number: true
---

# Huffman算法实现文件压缩解压

## 前言
&emsp;哈夫曼编码是一种贪心算法和二叉树结合的字符编码方式，具有广泛的应用背景，最直观的是文件压缩。下面讲述如何用哈夫曼编解码实现文件的压缩和解压。

## 哈夫曼编码的概念
&emsp;哈夫曼树又称作最优树，是一种带权路径长度最短的树，而通过哈夫曼树构造出的编码方式称作哈夫曼编码。
也就是说哈夫曼编码是一个通过哈夫曼树进行的一种编码，一般情况下，以字符 “0” 与 “1” 表示。编码的实现过程很简单，只要实现哈夫曼树，通过遍历哈夫曼树，这里我们从根节点开始向下遍历，如果下个节点是左孩子，则在字符串后面追加 “0”，如果为其右孩子，则在字符串后追加 “1”。结束条件为当前节点为叶子节点，得到的字符串就是叶子节点对应字符的编码。

## 哈夫曼编码用于文件压缩的原理
&emsp;我们都知道根据人类使用文字对应的每个字符都是有特定的频率的。比如说英文，一般来说字母a或者e的使用频率很高。如果我们能给出现频率最高的字符很短的编码，出现最少的字符最长的编码，而且保证每个编码都不是任意一个编码的前缀码。为什么要保证这样呢？如果任意一个编码都不是其他编码的前缀码，那么只要读到一个对应字符的编码那么它对应的字符只有一个，不会产生歧义，这样能保证根据压缩的编码来解压不会出现错误。如果我们用这样的编码来对一个文件进行压缩，那么出现最多的字符将会有最短的编码，可以节省很多的空间，将一个大的文件压缩成一个比较小的文件。而哈夫曼树就是一个可以用来生成这样一种编码的树，以树的叶子节点代表一个字符，从根节点到叶节点的路径形成一个编码，左子树表示比特1，右子树表示比特0，可以交换。这样每个字符对应一个唯一的编码而且任意一个编码都不是其他编码的前缀码。如果我们要压缩一个文件，需要先统计这个字符文件中每个字符出现的频率，然后根据频率来生成一颗哈夫曼树，使频率最高的字符对应于最短的编码。然后根据生成的编码对文件进行压缩。也就是把每个字符替换成其对应的编码来保存。生成后的压缩文件会比原来的文件小得多。然后有根据压缩的编码来对压缩的文件进行解压缩，也就是压缩的反过程。这样又可以恢复出原本的文件了。起到了文件压缩节省空间，同时还增加了文件的保密性。也可以看成是文件的加密和解密。

## 哈夫曼树实现及其效率

&emsp;根据贪心算法的思想实现，把字符出现频率较多的字符用稍微短一点的编码，而出现频率较少的字符用稍微长一点的编码。哈夫曼树就是按照这种思想实现，下面将举例分析创建哈夫曼树的具体过程。下面表格的每一行分别对应字符及出现频率，根据这些信息就能创建一棵哈夫曼树。

|字符  |出现频率|编码	|总二进制位数|
|:---:|:---:|:---:  |:---:|
|a	  |500	|1	    |500  |
|b	  |250	|01	    |500  |
|c	  |120	|001	|360  |
|d	  |60	|0001	|240  |
|e	  |30	|00001	|150  |
|f	  |20	|00000	|100  |

&emsp;如下图，将每个字符看作一个节点，将带有频率的字符全部放到优先队列中，每次从队列中取频率最小的两个节点 a 和 b（这里频率最小的 a 作为左子树），然后新建一个节点R，把节点设置为两个节点的频率之和，然后把这个新节点R作为节点A和B的父亲节点。最后再把R放到优先队列中。重复这个过程，直到队列中只有一个元素，即为哈夫曼树的根节点。

![](https://cdn.jsdelivr.net/gh/TOMsworkspace/BlogHelper/Huffman算法实现文件压缩解压/figure1.jpg)

&emsp;由上分析可得，哈夫曼编码的需要的总二进制位数为 500 + 500 + 360 + 240 + 150 + 100 = 1850。上面的例子如果用等长的编码对字符进行压缩，实现起来更简单，6 个字符必须要 3 位二进制位表示，解压缩的时候每次从文本中读取 3 位二进制码就能翻译成对应的字符，如 000，001，010，011，100，101 分别表示 a，b，c，d，e，f。则需要总的二进制位数为 （500 + 250 + 120 + 60 + 30 + 20）* 3 = 2940。对比非常明显哈夫曼编码需要的总二进制位数比等长编码需要的要少很多，这里的压缩率为 1850 / 2940 = 62%。哈夫曼编码的压缩率通常在 20% ~90% 之间。

## [代码实现](https://github.com/TOMsworkspace/Huffman_code_zip)
