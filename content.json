{"meta":{"title":"Tom's develop Blog","subtitle":"Love technology,love life.","description":"keep curiously!","author":"Tom","url":"https://TOMsworkspace.github.io","root":"/"},"pages":[{"title":"Category","date":"2019-11-08T08:22:30.000Z","updated":"2019-11-08T15:17:17.138Z","comments":false,"path":"categories/index.html","permalink":"https://tomsworkspace.github.io/categories/index.html","excerpt":"","text":""},{"title":"Link","date":"2019-11-08T08:26:24.000Z","updated":"2019-11-08T15:15:06.934Z","comments":true,"path":"link/index.html","permalink":"https://tomsworkspace.github.io/link/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-11-08T08:19:57.000Z","updated":"2019-11-08T15:16:18.819Z","comments":false,"path":"tags/index.html","permalink":"https://tomsworkspace.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CPU Cache","slug":"CPU-Cache","date":"2019-11-17T12:20:30.000Z","updated":"2019-11-17T13:02:22.000Z","comments":true,"path":"2019/11/17/CPU-Cache/","link":"","permalink":"https://tomsworkspace.github.io/2019/11/17/CPU-Cache/","excerpt":"","text":"Linux的CPU cache一． CPU 与 Memory 内存之间的三级缓存的实现原理1.1 cache 存在的原理引入 Cache 的理论基础是程序局部性原理，包括时间局部性和空间局部性。时间局部性原理即最近被CPU访问的数据，短期内CPU 还要访问（时间）；空间局部性即被CPU访问的数据附近的数据，CPU短期内还要访问（空间）。因此如果将刚刚访问过的数据缓存在一个速度比主存快得多的存储中，那下次访问时，可以直接从这个存储中取，其速度可以得到数量级的提高。CPU缓存是（Cache Memory）位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。在CPU中加入缓存是一种高效的解决方案，是对于存储器件成本更低，速度更快这两个互相矛盾的目标的一个最优解决方案，这样整个内存储器（缓存+内存）就变成了既有缓存的高速度，又有内存的大容量的存储系统了。缓存对CPU的性能影响很大，主要是因为CPU的数据交换顺序和CPU与缓存间的带宽引起的。下图是一个典型的存储器层次结构，我们可以看到一共使用了三级缓存 各级存储访问延迟的对比 1.2 cpu 三级cache介于CPU和主存储器间的高速小容量存储器，由静态存储芯片SRAM组成，容量较小但比主存DRAM技术更加昂贵而快速， 接近于CPU的速度。CPU往往需要重复读取同样的数据块， Cache的引入与缓存容量的增大，可以大幅提升CPU内部读取数据的命中率，从而提高系统性能。通常由高速存储器、联想存储器、地址转换部件、替换部件等组成。如图所示。 联想存储器：根据内容进行寻址的存储器（冯氏模型中是按照地址进行寻址，但在高速存储器中往往只存有部分信息，此时需要根据内容进行检索） 地址转换部件：通过联想存储器建立目录表以实现快速地址转换。命中时直接访问Cache；未命中时从内存读取放入Cache 替换部件：在缓存已满时按一定策略进行数据块替换，并修改地址转换部件 早期采用外部（Off-chip）Cache，不做在CPU内而是独立设置一个Cache。现在采用片内（On-chip）Cache，将Cache和CPU作在一个芯片上，且采用多级Cache，同时使用L1 Cache和L2 Cache，甚至有L3 Cache。 一般L1 Cache都是分立Cache，分为数据缓存和指令缓存，可以减少访存冲突引起的结构冒险，这样多条指令可以并行执行；内置；其成本最高，对CPU的性能影响最大多级Cache的情况下，L1 Cache的命中时间比命中率更重要 一般L2 Cache都是联合Cache，这样空间利用率高没有L3 Cache的情况下，L2 Cache的命中率比命中时间更重要（缺失时需从主存取数，并要送L1和L2 cache） L3 Cache多为外置，在游戏和服务器领域有效；但对很多应用来说，总线改善比设置L3更加有利于提升系统性能 上图显示了最简单的缓存配置。它对应着最早期使用CPU cache的系统的架构。CPU内核不再直接连接到主内存。所有的数据加载和存储都必须经过缓存。CPU核心与缓存之间的连接是一种特殊的快速连接。在一个简化的表示中，主存和高速缓存连接到系统总线，该系统总线也可用于与系统的其他组件进行通信。我们引入了系统总线（现代叫做“FSB”）。引入缓存后不久，系统变得更加复杂。高速缓存和主存之间的速度差异再次增大，使得另一个级别的高速缓存不得不被添加进来，它比第一级高速缓存更大且更慢。出于经济原因，仅增加第一级缓存的大小不是一种选择。今天，甚至有机器在生产环境中使用了三级缓存。带有这种处理器的系统如图下所示。随着单个CPU的内核数量的增加，未来的缓存级别数量可能会增加。现在已经出现了拥有四级cache的处理器了。 上图展示了三级缓存的结构。L1d是一级数据cache，L1i是一级指令cache。请注意，这只是一个示意图; 现实中的数据流从core到主存的过程中不需要经过任何更高级别的cache。CPU设计人员有很大的自由来设计cache的接口。对于程序员来说，这些设计选择是不可见的。另外，我们有拥有多个core的处理器，每个core可以有多个“线程”。核心和线程之间的区别在于，独立的核心具有所有硬件资源的独立的副本，早期的多核处理器，甚至具有单独的第二级缓存而没有第三级缓存。核心可以完全独立运行，除非它们在同一时间使用相同的资源，例如与外部的连接。另一方面，线程们共享几乎所有的处理器资源。英特尔的线程实现只为线程提供单独的寄存器，甚至是有限的，还有一些寄存器是共享的。一个现代CPU的完整概貌如图所示。 i-cache和d-cache都是32KB、8路、4个时钟周期； L2 cache：256KB 、8路、11个时钟周期。 所有核共享的L3 cache：8MB、16路、30~40个时钟周期。 Core i7中所有cache的块大小都是64B 1.3 cpu cache与TLB的联系由于cache中对应的都是主存地址，即物理地址，在cqu查看具体数据是否在cache中时，如果CPU传送过来的地址时一个虚拟地址，需要将其转换成实际物理地址再到cache中去寻找。Cache的实现需要TLB的帮助。可以说TLB命中是Cache命中的基本条件。TLB不命中，会更新TLB项，这个代价非常大，Cache命中的好处基本都没有了。在TLB命中的情况下，物理地址才能够被选出，Cache的命中与否才能够达成。 1.3.1 TLB的概述TLB是一个内存管理单元用于改进虚拟地址到物理地址转换速度的缓存。TLB是位于内存中的页表的cache，如果没有TLB，则每次取数据都需要两次访问内存,即查页表获得物理地址和取数据。 1.3.2 TLB的原理当cpu对数据进行读请求时,CPU根据虚拟地址(前20位)到TLB中查找.TLB中保存着虚拟地址(前20位)和页框号的对映关系,如果匹配到虚拟地址就可以迅速找到页框号(页框号可以理解为页表项),通过页框号与虚拟地址后12位的偏移组合得到最终的物理地址.如果没在TLB中匹配到虚拟地址,就出现TLB丢失,需要到页表中查询页表项,如果不在页表中,说明要读取的内容不在内存,需要到磁盘读取.TLB是MMU中的一块高速缓存,也是一种Cache.在分页机制中,TLB中的数据和页表的数据关联,不是由处理器维护,而是由OS来维护,TLB的刷新是通过装入处理器中的CR3寄存器来完成.如果MMU发现在TLB中没有命中,它在常规的页表查找后,用找到的页表项替换TLB中的一个条目. 1.3.3 TLB的刷新原则当进程进行上下文切换时重新设置cr3寄存器,并且刷新tlb.有两种情况可以避免刷tlb. 第一种情况是使用相同页表的进程切换. 第二种情况是普通进程切换到内核线程.lazy-tlb(懒惰模式)的技术是为了避免进程切换导致tlb被刷新.当普通进程切换到内核线程时,系统进入lazy-tlb模式,切到普通进程时退出该模式. 1.3.4 cache的概念cache是为了解决处理器与慢速DRAM(慢速DRAM即内存)设备之间巨大的速度差异而出现的。cache属于硬件系统,linux不能管理cache.但会提供flush整个cache的接口.cache分为一级cache,二级cache,三级cache等等.一级cache与cpu处于同一个指令周期. 1.3.5 Cache的存取单位(Cache Line)CPU从来不从DRAM直接读/写字节或字,从CPU到DRAM的每次读或写的第一步都要经过L1 cache,每次以整数行读或写到DRAM中.Cache Line是cache与DRAM同步的最小单位.典型的虚拟内存页面大小为4KB,而典型的Cache line通常的大小为32或64字节.CPU 读/写内存都要通过Cache,如果数据不在Cache中,需要把数据以Cache Line为单位去填充到Cache,即使是读/写一个字节.CPU 不存在直接读/写内存的情况,每次读/写内存都要经过Cache. 1.3.6 Cache的工作模式 数据回写(write-back):这是最高性能的模式,也是最典型的,在回写模式下,cache内容更改不需要每次都写回内存,直到一个新的 cache要刷新或软件要求刷新时,才写回内存. 写通过(write-through):这种模式比回写模式效率低,因为它每次强制将内容写回内存,以额外地保存cache的结果,在这种模式写耗时,而读和回写模一样快,这都为了内存与cache相一致而付出的代价. 预取 (prefectching):一些cache允许处理器对cache line进行预取,以响应读请求,这样被读取的相邻内容也同时被读出来,如果读是随机的,将会使CPU变慢,预取一般与软件进行配合以达到最高性能. 二. 各级缓存中数据的包含关系2.1 整个缓存和主存间缓存里有的数据，主存中一定存在。 2.2 各级缓存之间一级缓存中还分数据缓存（data cache，d-cache）和指令缓存（instruction cache，i-cache）。二者分别用来存放数据和执行这些数据的指令，而且两者可以同时被cpu访问，所以一级cache间数据时独立的。 一级没有的数据二级可能有也可能没有。因为一级缓存miss会接着访问二级缓存。 一级有二级一定有，三级也一定有。因为一级的数据从二级中读上来的。在一级缺失二级命中时发生。 二级没有的数据三级可能有也可能没有。因为二级确实会接着访问三级缓存。找不到会继续访问主存。 二级有的数据三级一定有。在二级缺失三级命中时，数据会从三级缓存提到二级缓存。 三级没有的数据，主存可能有也可能没有。三级缓存缺失，会访问主存，主存也缺失就要从外存访问数据了。 三级缓存有的数据主存一定有。因为在三级缺失主存命中时，数据会从主存提到三级缓存中来。 三. 各级缓存的大小设置一级缓存就是指CPU第一层级的高速缓存，主要是为了缓存指令和缓存数据，一级缓存的容量对CPU性能影响非常大，但是因为成本太高，所以一般容量特别小，也就256KB左右。 二级缓存是CPU第二层级的高速缓存，对于CPU来说，二级缓存容量越大越好，它是直接影响CPU性能的，CPU每个核心都会有自己的缓存，一个CPU的二级缓存容量是所有核心二级缓存容量的总和。 三级缓存就是CPU第三层级的高速缓存，主要是为了降低与内存进行数据传输时的延迟问题，三级缓存与一二级不同，三级缓存只有一个，它是所有核心共享，所以在CPU参数中可以看到，三级缓存相对于其他两级缓存来说都很大。 由于缓存的设置与OS无关且透明，所以对于不同的体系架构下不同的处理器对待缓存区域的处理和方式都不同，不同的处理器也有不同的缓存设置值。从主流的处理器cache大小来看，一般一个cache line的大小都是固定的64B左右，这是经过经验得到的比较合理的大小，一般一级cache大小在数十KB左右，二级cache大小在数十到数百KB左右，而L3 cache大小在数MB左右。 四. 各级缓存之间的数据放置与数据淘汰策略由于三级cache一般来说是运用于拥有多核的处理器，对于单核处理器来说二级cache就能够足够保持够高的cache命中率。所以一般的三级cache一般只针对于多核处理器。L1和L2级cache是处理器核所单独的内容。L1又可以看成是L2的cache。L2可以看成是L3级cache的cache。所以我们分两个部分讨论数据放置与数据淘汰策略。 4.1 各级cache之间数据放置方式各级cache间的数据放置策略主要有三种。直接相连映射，全相联映射和组相联映射。将一个主存块存储到唯一的一个Cache行。对应的大小都是一个cache line的大小，一般来说是64B。 4.1.1直接相连映射多对一的映射关系，但一个主存块只能拷贝到cache的一个特定行位置上去。cache的行号i和主存的块号j有如下函数关系：i=j mod m（m为cache中的总行数）。 优点：硬件简单，容易实现 缺点：命中率低， Cache的存储空间利用率低 4.1.2全相联映射可以将一个主存块存储到任意一个Cache行。主存的一个块直接拷贝到cache中的任意一行上 优点：命中率较高，Cache的存储空间利用率高 缺点：线路复杂，成本高，速度低 4.1.3组相联映射可以将一个主存块存储到唯一的一个Cache组中任意一个行。将cache分成u组，每组v行，主存块存放到哪个组是固定的，至于存到该组哪一行是灵活的，即有如下函数关系：cache总行数m＝u×v 组号q＝j mod u 组间采用直接映射，组内为全相联。硬件较简单，速度较快，命中率较高。是现代处理器中一般所常用的映射方式。4.2 数据淘汰策略Cache工作原理要求它尽量保存最新数据，当从主存向Cache传送一个新块，而Cache中可用位置已被占满时，就会产生Cache替换的问题。常用的替换算法有下面三种。 4.2.1 LFULFU（Least Frequently Used，最不经常使用）算法将一段时间内被访问次数最少的那个块替换出去。每块设置一个计数器，从0开始计数，每访问一次，被访块的计数器就增1。当需要替换时，将计数值最小的块换出，同时将所有块的计数器都清零。这种算法将计数周期限定在对这些特定块两次替换之间的间隔时间内，不能严格反映近期访问情况，新调入的块很容易被替换出去。 4.2.2 LRULRU（Least Recently Used，近期最少使用）算法是把CPU近期最少使用的块替换出去。这种替换方法需要随时记录Cache中各块的使用情况，以便确定哪个块是近期最少使用的块。每块也设置一个计数器，Cache每命中一次，命中块计数器清零，其他各块计数器增1。当需要替换时，将计数值最大的块换出。LRU算法相对合理，但实现起来比较复杂，系统开销较大。这种算法保护了刚调入Cache的新数据块，具有较高的命中率。LRU算法不能肯定调出去的块近期不会再被使用，所以这种替换算法不能算作最合理、最优秀的算法。但是研究表明，采用这种算法可使Cache的命中率达到90%左右。 4.2.3 随机替换最简单的替换算法是随机替换。随机替换算法完全不管Cache的情况，简单地根据一个随机数选择一块替换出去。随机替换算法在硬件上容易实现，且速度也比前两种算法快。缺点则是降低了命中率和Cache工作效率。 五. 整个缓存结构的访问流程5.1 查找命中处理器微架构访问Cache的方法与访问主存储器有类似之处。主存储器使用地址编码方式，微架构可以地址寻址方式访问这些存储器。Cache也使用了类似的地址编码方式，微架构也是使用这些地址操纵着各级Cache，可以将数据写入Cache，也可以从Cache中读出内容。只是这一切微架构针对Cache的操作并不是简单的地址访问操作。为简化起见，我们忽略各类Virtual Cache，讨论最基础的Cache访问操作，并借此讨论CPU如何使用TLB完成虚实地址转换，最终完成对Cache的读写操作。 Cache的存在使得CPU Core的存储器读写操作略微显得复杂。CPU Core在进行存储器方式时，首先使用EPN(Effective Page Number)进行虚实地址转换，并同时使用CLN(Cache Line Number)查找合适的Cache Block。这两个步骤可以同时进行。在使用Virtual Cache时，还可以使用虚拟地址对Cache进行寻址。为简化起见，我们并不考虑Virtual Cache的实现细节。 EPN经过转换后得到VPN，之后在TLB中查找并得到最终的RPN(Real Page Number)。如果期间发生了TLB Miss，将带来一系列的严重的系统惩罚，我们只讨论TLB Hit的情况，此时将很快获得合适的RPN，并依此得到PA(Physical Address)。 在多数处理器微架构中，Cache由多行多列组成，使用CLN进行索引最终可以得到一个完整的Cache Block。但是在这个Cache Block中的数据并不一定是CPU Core所需要的。因此有必要进行一些检查，将Cache Block中存放的Address与通过虚实地址转换得到的PA进行地址比较(Compare Address)。如果结果相同而且状态位匹配，则表明Cache Hit。此时微架构再经过Byte Select and Align部件最终获得所需要的数据。如果发生Cache Miss，CPU需要使用PA进一步索引主存储器获得最终的数据。 由上文的分析，我们可以发现，一个Cache Block由预先存放的地址信息，状态位和数据单元组成。一个Cache由多个这样的Cache Block组成，在不同的微架构中，可以使用不同的Cache Block组成结构。我们首先分析单个Cache Block的组成结构。单个Cache Block由Tag字段，状态位和数据单元组成，如图所示。 其中Data字段存放该Cache Block中的数据，在多数处理器微架构中，其大小为32或者64字节。Status字段存放当前Cache Block的状态，在多数处理器系统中，这个状态字段包含MESI，MOESI或者MESIF这些状态信息，在有些微架构的Cache Block中，还存在一个L位，表示当前Cache Block是否可以锁定。许多将Cache模拟成SRAM的微架构就是利用了这个L位。有关MOESIFL这些状态位的说明将在下文中详细描述。在多核处理器和复杂的Cache Hierarchy环境下，状态信息远不止MOESIF。 RAT(Real Address Tag)记录在该Cache Block中存放的Data字段与那个地址相关，在RAT中存放的是部分物理地址信息，虽然在一个CPU中物理地址可能有40，46或者48位，但是在Cache中并不需要存放全部地址信息。因为从Cache的角度上看，CPU使用的地址被分解成为了若干段，如图所示。 这个地址也可以理解为CPU访问Cache使用的地址，由多个数据段组成。首先需要说明的是Cache Line Index字段。这一字段与Cache Line Number类似，CPU使用该字段从Cache中选择一个或者一组Entry。 Bank和Byte字段之和确定了单个Cache的Data字段长度，通常也将这个长度称为Cache 行长度，上图所示的微架构中的Cache Block长度为64字节。目前多数支持DDR3 SDRAM的微架构使用的Cache Block长度都是64字节。部分原因是由于DDR3 SDRAM的一次Burst Line为8，一次基本Burst操作访问的数据大小为64字节。 &#160;在处理器微架构中，将地址为Bank和Byte两个字段出于提高Cache Block访问效率的考虑。Multi-Bank Mechanism是一种常用的提高访问效率的方法，采用这种机制后，CPU访问Cache时，只要不是对同一个Bank进行访问，即可并发执行。Byte字段决定了Cache的端口位宽，在现代微架构中，访问Cache的总线位宽为64位或者为128位。 &#160;剩余的字段即为Real Address Tag，这个字段与单个Cache中的Real Address Tag的字段长度相同。CPU使用地址中的Real Address Tag字段与Cache Block的对应字段和一些状态位进行联合比较，判断其访问数据是否在Cache中命中 5.2 cache 不命中如果cache miss,就去下一级cache或者主存中去查找数据，并将查找到的数据采用上面的数据淘汰策略将数据替换到cache中。 5.3 cache和主存数据一致性保持由于在发生cache miss时会产生数据替换，在运行过程中缓存的数据也可能会被修改。所以需要一个策略来保持数据在缓存和主存间的一致性。Cache写机制分为write through和write back两种。 Write-through（直写模式）在数据更新时，同时写入缓存Cache和主存存储。此模式的优点是操作简单；缺点是因为数据修改需要同时写入存储，数据写入速度较慢。 Write-back（回写模式）在数据更新时只写入缓存Cache。只在数据被替换出缓存时，被修改的缓存数据才会被写到后端存储。此模式的优点是数据写入速度快，因为不需要写存储；缺点是一旦更新后的数据未被写入存储时出现系统掉电的情况，数据将无法找回。","categories":[{"name":"Linux kernel","slug":"Linux-kernel","permalink":"https://tomsworkspace.github.io/categories/Linux-kernel/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://tomsworkspace.github.io/tags/cache/"},{"name":"CPU cache","slug":"CPU-cache","permalink":"https://tomsworkspace.github.io/tags/CPU-cache/"},{"name":"三级缓存","slug":"三级缓存","permalink":"https://tomsworkspace.github.io/tags/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"},{"name":"缓存映射","slug":"缓存映射","permalink":"https://tomsworkspace.github.io/tags/%E7%BC%93%E5%AD%98%E6%98%A0%E5%B0%84/"},{"name":"cache原理","slug":"cache原理","permalink":"https://tomsworkspace.github.io/tags/cache%E5%8E%9F%E7%90%86/"},{"name":"多级cache","slug":"多级cache","permalink":"https://tomsworkspace.github.io/tags/%E5%A4%9A%E7%BA%A7cache/"},{"name":"TLB","slug":"TLB","permalink":"https://tomsworkspace.github.io/tags/TLB/"}]},{"title":"搭建个人博客","slug":"搭建个人博客","date":"2019-11-13T08:36:37.000Z","updated":"2019-11-15T09:05:42.430Z","comments":true,"path":"2019/11/13/搭建个人博客/","link":"","permalink":"https://tomsworkspace.github.io/2019/11/13/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"对于常年需要学习新东西的人们，经常想把学过的一些东西整理一下。于是写博客就成了很多人整理自己学习过的东西的很好的方式。有人选择在一些成熟的平台上管理自己的博客，比如知乎，CSDN，简书这些平台。不过在别人的平台上写东西很容易受到各种限制，内容也有各种各样的要求。哪有比自己搭一个私人博客网站更炫酷（装*）的呢！！！！ 哈哈，let’s go.","text":"对于常年需要学习新东西的人们，经常想把学过的一些东西整理一下。于是写博客就成了很多人整理自己学习过的东西的很好的方式。有人选择在一些成熟的平台上管理自己的博客，比如知乎，CSDN，简书这些平台。不过在别人的平台上写东西很容易受到各种限制，内容也有各种各样的要求。哪有比自己搭一个私人博客网站更炫酷（装*）的呢！！！！ 哈哈，let’s go. 一.效果展示经过特别简单的配置（大概几个小时），一个属于个人的博客网站就搭好了，可以开始更新自己的内容了，毕竟内容才是最重要的啊。 效果如下： 二.前期准备经过总结前人的经验，我把搭建一个个人的博客分为大概三种可行的方案： 第一种方案：搭建一个通过Github pages访问的博客网站。但是这样的话只能通过访问 http://github用户名.github.io的方式访问自己的博客网站，毕竟不够炫酷，但是是免费的。于是有了第二种方案。 第二种方案：把 http://github用户名.github.io绑定到自己的域名，购买一个域名需要一定的费用。 第三种方案：把博客系统放到自己购买服务器上，这样能通过服务器的IP地址访问博客网站，绑定域名后可以通过域名来访问。这是最炫酷的方式，当然也是pay最多的，而且网站还需要经过备案。 由于自己热爱open sourse（其实是没钱），于是我选择了第一种的方案。希望后面有钱了可以实现第三种方案。哈哈。 2.1 选择一个博客框架为了避免重复造轮子，也为了简单和高效起见，我们需要选择一个已有的博客框架，再在这些框架的基础上搭建。有很多还不错的开源博客框架可以选择。简单列举几个： - Jekyll - hugo - django - hexo 经过比较，发现hexo框架还不错，有比较好的扩展性和很大的用户基础。于是Tom就选了hexo作为博客的框架。想选择其他框架的请参照具体官网文档,和他们的GitHub issues。 2.2 hexo框架的简介Hexo 特点 支持Markdown: 支持Markdown意味着你可以把经历从排版中解放出来 轻量: 无需拥有后台及数据库,专心写好你的文章 一键部署: 可以通过Git或者ftp来将生成的静态页面部署到服务器或者主机空间中 插件丰富: 丰富的插件可以满足你的各种需求 其他特性，请参考官方文档. 2.3 配置必要的环境搭建前期需要四个工具 Hexo:Hexo快速、简洁且高效的博客框架 Node.js:建立在Chrome上的JavaScript运行引擎 Git:一款免费、开源的分布式版本控制系统 GitHub:国内一款面向开发者的云端开发平台，提供代码托管，运行空间，质量控制，项目管理等功能安装 安装必要的配置环境，如果已经安装过，可以跳过。 2.3.1 安装Git Git官网找到Download,安装自己对应的系统版本，系统会自动判定你当前版本，推荐下载，如果没有推荐，那就自己选择吧。 安装完后，用win+R打开cmd界面，输入 $git --version 出现git的版本信息说明安装成功。 然后熟悉一下Git管理Github项目的常用命令，理解一下他们的关系,感受一下git版本和分支管理的强大之处。 2.3.2 安装Node.js Node.js下载地址安装node.js记得选择add to path选项，或者手动配置环境变量。把node所在的bin目录加入环境变量。用win+R打开cmd界面，输入 $node 出现node.js的版本信息说明安装成功。 同理系统依然会判定你的系统并给出稳定推荐的版本和尝鲜版，两种，供君选择。下载安装步骤同样省略。 2.3.3 GitHub账号注册GitHub账号注册过程很简单，注册流程就省略，完成之后，就开始创建博客了。注册完成后，创建名字为 username.github.io 的仓库,username是你的github用户名。记住一定是这个名字的仓库，不然会出问题的。 2.3.4 安装Hexo前面的所有工具安装完成后，在git bash或者cmd界面中使用npm安装hexo。 $npm install -g hexo-cli 进阶安装和使用,对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。 $npm install hexo 安装 Hexo 完成后，请执行下列命令查看安装hexo的版本信息。 $hexo version 然后运行以下命令，Hexo 将会在指定文件夹中新建所需要的文件。这个指定的文件夹就是保存你的博客站点所有文件的地方。 $hexo init &lt;folder&gt;$cd &lt;folder&gt; $npm install 站点文件包含以下的文件 . ├── _config.yml //网站的配置文件 ├── package.json //应用程序的信息 ├── scaffolds //模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 ├── source //资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 | ├── _drafts | └── _posts └── themes //主题 文件夹。Hexo 会根据主题来生成静态页面。更多关于站点目录和配置文件的信息。 安装git,hexo，node.js后，熟悉相关命令。不同系统环境下安装遇到的问题请参考官方文档,官方文档支持中英文，很方便。 三.hexo框架搭建博客3.1 建立hexo项目，本地localhost:port访问在上一步生成了站点文件夹后，其中会有一个默认主题以及一个hello-word的默认文章。所以我们可以先生成博客来看一下效果，在站点所在目录打开git bash运行命令： $hexo generate //可以简写成$hexo g 然后hexo会开始生成博客，生成结束后，文件夹下会多出一个public的文件夹，这个文件夹就是hexo生成的一个完整的静态网站，也就是我们的博客。网站生成好了，我们要浏览它，所以要开启一下hexo自带的服务器，运行命令： $hexo server //可以简写成$hexo s 这时候，打开浏览器，输入localhost：4000即可访问博客网站。如果出现端口冲突，可以使用如下的命令指定其他端口。再使用localhost：port去访问。 $hexo server -p port //可以简写成$hexo g -p port 3.2 远程部署，绑定SSH,域名访问远程部署指的是，博客在我们本地生成好了以后部署到远程仓库去，如果远程仓库支持pages服务的话，那就可以通过这样的方法发布和更新博客。要使用远程部署需要先安装hexo-deployer-git，注意，这是适用于git类型仓库的方法，其他仓库的方法在官网中有说明。 运行命令 $npm install hexo-deployer-git --save //安装hexo-deployer-git package 安装好hexo-deployer-git后，修改博客目录配置文件_config.yml中的deploy字段，用记事本打开就可以： deploy: type: git //pages 部署仓库类型 repo: //git仓库项目地址，你建立的 用户名.github.io仓库 branch: //分支，默认是master message: //自定义提交说明，这个字段可以没有，用于描述你的提交再运行 $hexo deploy 打开github的repo,发现你的仓库里已经有了文件，这是生成的博客网站的静态文件。也就是本地博客文件夹中的public 或者.deploy_git中的内容。hexo生成了你的博客网站的静态文件。在浏览器地址栏输入http://username.github.io就可以访问你的个人博客网站了。很炫酷吧。 参考的一些资料 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhttps://blog.csdn.net/gsl9d1p04f6x2ts3c9/article/details/81024330https://blog.csdn.net/dazhaoDai/article/details/73730069https://www.jianshu.com/p/343934573342 绑定SSH Git使用https协议，每次pull, push都要输入密码，相当的烦。使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。为了方便你的博客的提交，你可以进行git与repo仓库的SSH绑定。 SSH绑定git仓库的特点： ssh方式单独使用非对称的秘钥进行认证和加密传输，和账号密码分离开来，不需要账号也可以访问repo。 生成和管理秘钥有点繁琐，需要管理员添加成员的public key。不能进行匿名访问，ssh不利于对权限进行细分，用户必须具有通过SSH协议访问你主机的权限，才能进行下一步操作，比较适合内部项目。 如何进行SSH配置。 四.更换主题4.1 给你的博客选择一个主题经过以上的配置，你的博客网站已经跑起来了。不过是不是有点丑呢？看来需要进一步的美化我们的网站啊。当然Hexo,也大力支持我们的想法，Hexo提供了很多漂亮的主题供我们选择。Hexo主题。是不是发现有很多主题让你眼花缭乱了，如果不知道应该选哪一个，可以听一听来自前人的建议主题推荐1 主题推荐2。 4.2 更改相关配置找到自己喜欢的主题，把对应的主题下载到本地站点文件夹下的themes文件夹下。Tom选择了一个名为Butterfly的主题。想要让这个主题应用到我自己的站点上。需要进行如下的操作。 下载主题 找到下载主题的Github repo地址，在站点文件夹下右键打开git bash,输入命令 $git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 如果想要安装比较新的dev分支，可以 $git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 应用主题 修改hexo配置文件_config.yml，把主题改为Butterfly theme: Butterfly对于不同的主题，可能还有其他的配置才能生效，参加你选择主题的相关文档说明，关于主题Butterfly配置。 如果你没有pug以及stylus的渲染器，请下载安装： $npm install hexo-renderer-pug hexo-renderer-stylus --save 或者 $yarn add hexo-renderer-pug hexo-renderer-stylus 然后再次generate ,depoly，访问地址，主题就更换好了。 疑难问题解决 五.项目管理5.1 写博客，删除博客首先，由于hexo是支持Markdown来编写你的博客的，非常方便。markdown语法也是非常简单的，类似于html,很快就能掌握。在开始写你的博客之前需要先掌握一下。 但是在实际使用时发现了一个问题。在不同的平台对于markdown语法的支持不太一样，但是大多是东西是一样的，对于博客在不同平台间的迁移不太方便。暂时没有太好的解决办法，等有比较好的解决方法时更新一下。hexo支持的markdown 语法和github的markdown语法是一样的。然后最好是选择一个对于hexo markdown语法支持得比较好的makedown编辑器。 其他的markdown语法资料 https://segmentfault.com/markdown https://www.jianshu.com/p/8c1b2b39deb0 5.2 上传更新博客先在本地预览一下写好的博客，在站点文件夹下使用git bash运行 $hexo generate //hexo g$hexo server //hexo s 检查没问题后，提交更新 $hexo deploy //hexo d 六.高级功能6.1 评论管理如何给我们的评论添加评论功能呢？ 以Tom选择的Butterfly主题为例，打开主题的配置文件夹_config.yml,注意不是站点的配置文件。搜索Comments,发现该主题支持如下的几种评论系统 disqus laibili gitalk valine 可以任选一种评论系统进行配置。大致流程为先注册对应的评论系统，再进行一些配置。主题Butterfly相关配置参见主题butterfly相关文档。 其他的配置方法。 6.2 绑定域名是不是感觉使用githubusername.github.io访问自己的博客还是不够炫酷呢？于是可以给自己的网站绑定一个炫酷的域名，也就是相当于给你的网站起了一个别名，本质上都是通过DNS查找ip地址，然后通过IP地址访问的你的网站的。 可以在CMD界面下通过命令来查看你博客的ip地址。 $ping username.github.io //ping 你的博客网址 首先注册一个域名，在阿里云上注册或者买一个域名。打开控制台，点击解析域名，把你刚刚查到的ip地址填到刚刚解析的域名的记录值上面。然后在你的博客文件夹下面新建一个名为CNAME的文件，在里面写入你刚刚购买的域名。然后提交你的站点静态文件到仓库里。等待一段时间，然后就可以通过刚刚购买的域名访问你的网站了。 6.3 部署站点到自己的服务器如果你觉得上面的配置还不过炫酷，速度不够快，毕竟github是国外的网站，那么还有更厉害的，把网站放到自己的服务器上。 网站备案 首先，需要进行网站备案。根据工信部《互联网信息服务管理办法》(国务院 292 号令)，网站在未完成备案之前，不能指向大陆境内服务器开通访问。如果您的网站托管在中国大陆节点服务器，或者开通 CDN 服务，就必须申请 ICP(互联网内容提供商)备案。若网站服务器为非中国大陆节点，则不用申请备案。 然后购买一个服务器，把你的域名绑定到你的服务器上。 在你的服务器上安装Git并配置,安装并搭建web容器，如nginx,Tomcat等。 然后服务器获取站点静态文件有两种方式： 通过把站点静态文件直接提交到服务器上的git仓库 通过从github上的username.github.io获取站点静态文件 这样就完成了最后的配置。 6.4 更换电脑或重装系统后恢复hexo当我们的系统崩溃或者是其他原因导致hexo不能用了，试试这个恢复。 6.5 配置一键部署：每次更新博客都需要进到博客站点下进行操作，还有一堆的命令要输入。配置一键部署。 6.6 自定义什么？ 你觉得所有的主题都不符合你的要求。没问题，hexo也支持你自己DIY主题，还可以发布给大家一起用。还支持自定义博客模板等功能。 6.7 博客迁移你想把自己博客发布到不同的平台上，或者是从其他平台上添加自己的博客。没问题，hexo也支持。试试博客迁移。 6.8 搜索引擎收录博客当我们一开始建完博客时，搜索引擎是搜索不到的，我们需要做一项工作就是通知搜索引擎收录我们的网站。 具体方法 七.出现的一些问题git ssh配置Host key verification failed.YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column bad indentation of a mapping entry at line 199, column 2:hexo YAMLException: cannot read a block mapping entry; a multi line key may not be an implicit key agitalk 出现not found 等问题深坑，申请gitalk账号一般不会出问题，一般问题出在配置_config.yml上。注意repo是只写仓库名字，不是全部路径啊。如username.github.io这样。 butterfly主题问题解答更多问题解答","categories":[{"name":"其他","slug":"其他","permalink":"https://tomsworkspace.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"TOM","slug":"TOM","permalink":"https://tomsworkspace.github.io/tags/TOM/"},{"name":"个人博客","slug":"个人博客","permalink":"https://tomsworkspace.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"personal blog","slug":"personal-blog","permalink":"https://tomsworkspace.github.io/tags/personal-blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://tomsworkspace.github.io/tags/Hexo/"},{"name":"Github pages","slug":"Github-pages","permalink":"https://tomsworkspace.github.io/tags/Github-pages/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-07T15:02:58.834Z","updated":"2019-11-14T14:49:59.053Z","comments":true,"path":"2019/11/07/hello-world/","link":"","permalink":"https://tomsworkspace.github.io/2019/11/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}